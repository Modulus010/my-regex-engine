# Build My Own Regex Engine

一个从零开始实现的正则表达式（regex）引擎，旨在探索正则表达式解析、自动机构建和模式匹配的核心原理。

---

## 功能特性

### 🎯 支持的功能
- **定位符**：支持 `^`（匹配字符串开头）和 `$`（匹配字符串结尾）定位。
- **或操作**：实现 `|` 操作符，在多个模式之间进行选择。
- **范围匹配**：支持 `?`、`+`、`*` 和 `{n(,(m))}` 指定匹配次数。
- **字符集**：匹配方括号 `[]` 内的任意字符。
- **通配符**：`.` 匹配任意单个字符。
- **优先级控制**：使用 `()` 定义分组和子模式的操作优先级。

### 🚫 不支持的功能
- **转义字符**：暂不支持通过 `\` 转义特殊字符。
- **否定字符集**：未实现 `[^]` 表示匹配不在集合中的字符。
- **非贪婪匹配**：仅支持贪婪匹配模式，未实现非贪婪模式。

---

## 实现细节

### 🔍 正则表达式解析
- 使用 **递归下降解析** 将正则表达式转换为 **抽象语法树（AST）**。

### ⚙️ AST 到 NFA 的转换
- 应用 **汤普森构造算法** 将 AST 转换为等价的 **非确定性有限自动机（NFA）**。

### 🚀 模式匹配
- 使用 **子集构造法** 模拟 NFA 的运行以高效执行模式匹配。
- 针对极端情况（如 `a?{20}a{20}`）进行优化，避免指数复杂度。

---

## 未实现功能
- **NFA 到 DFA 的转换**：尚未实现 NFA 到确定性有限自动机（DFA）的转换。
- **DFA 状态缓存**：未实现使用状态缓存优化 DFA 转换性能。

---

## 项目目标
本项目旨在通过实践：
- 理解正则表达式解析和自动机理论。
- 探索 NFA 在模式匹配中的实际应用。
- 深入学习实现汤普森构造法和子集构造算法。

---

## 示例用法
给定以下正则表达式：
```regex
^(a|b)*c{2,4}$
```
和测试字符串：
```text
"abaccc"
```
引擎将执行以下步骤：
1. 将正则表达式解析为 AST。
2. 将 AST 转换为 NFA。
3. 模拟 NFA 判断测试字符串是否匹配模式。

```go
parse.NewParser("^(a|b)*c{2,4}$").Parse().ToNFA().Match("abbaccc")
```

---

## 贡献
欢迎对本项目进行贡献！如果您希望改进功能、修复 Bug 或增加对未支持功能的实现，欢迎提交 Pull Request。

---

感谢您关注！🚀

